# Goroutines和Channels
### 1.gr
```
    gr = goroutines
    ① 可以先类比线程理解
    ② main函数返回时,所有的gr都会被直接打断,程序退出
    ③ 没有其他方法让一个gr打断另一个gr的执行,但可以在gr之间通信,
      满足条件则自我结束
```
### 2.实例:并发的clock服务
```
    网络编程是并发大显身手的一个领域
```
### 3.channels:go通信机制
``` 
    ch = channel
    ① 每个ch都有特殊的类型,一个可以发送int类型的ch写作chan int
      例:
        ch := make(chan int)
    ② ch对应make创建的底层数据结构的引用,复制ch或用于函数参数时,只是拷贝了一个ch引用
    ③ ch主要有发送和接收两个操作
      使用 <- 运算符来进行发送或接收
      例:
        ch <- x //发送
        x = <- ch //接收
        <- ch //丢弃结果
    ④ ch支持close操作
      close(ch),被close后的ch依然可以接收之前成功发送的数据
    ⑤ 创建ch
      ch := make(chan int) // 无缓存ch
      ch := make(chan int,3) //带缓存的ch,容量为3
```
### 4.ch类型
```
    ① 不带缓存的ch
        也称为同步ch
        使用无缓存的ch,发送操作会使发送者所在的gr阻塞,直到另一个gr在相同的ch上接收数据,完成发送和接收后,两个相关的gr才可能执行后面的程序语句,先接收亦然
    ② 串联的ch(pipeline)
        ch1 -> ch2 -> ch3
        x , ok := <- ch //ok为false时,ch已经关闭
    ③ 单方向的ch
        chan <- int //只能发送数据 
        <- chan int //只能接收数据, x := <- ch
        关闭一个只能接收的ch会发送编译错误
    ④ 带缓存的ch
        内部有个元素队列,先进先出
        发送时,队满则阻塞
        接收时,队空则阻塞
        cap()可获得ch的缓存大小
```
### 5.gr和线程
```
    ① 一个os线程有一个固定内存大小(一般会是2MB)来做栈
        而gr的栈是动态调整的
    ② os线程会被操作系统内核调度
        Go运行时包含了自己的调度器,调度方式不需要进入内核的上下文,所以代价比线程低得多
    ③ GOMAXPROCS
        一个变量,决定会有多少个操作系统的线程同时执行go代码,默认值一般是机器上的CPU的核心数
    ④ gr没有id号
        设计上故意的
```