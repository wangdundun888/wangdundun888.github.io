### 问题

    n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

    如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。
    
    给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。

    输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
    输出：5
    解释：一种移除 5 块石头的方法如下所示：
    1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
    2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
    3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
    4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
    5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
       石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。

### 思考

    在分析示例1的时候，我想到了，如果两个点在同行或者同列，那么这两个点可以看作是一个互相连接的无向连通图，在一个连接的无向连通图里，先
    去掉最外层的一个点，最后必然剩下一个点，意思是说，一个无向连通图里就剩一个点。
    
    本题可以看看，还剩几个点，那么就是剩下几个石子没有被移除，一时没想到好的解决方法，所以选择看题解。

### 题解

    题解用到了并查集，之前用过并查集，仅限一维的，今天是二维的：
        
    方法：并查集
    删到最后，留在图中的顶点一定位于不同的行和不同的列。因此，并查集里的元素是 描述「横坐标」和「纵坐标」的数值。因此我们需要遍历数组 stones，将每个 stone 的横坐标和纵坐标在并查集中进行合并。理解合并的语义十分重要。

    「合并」的语义
    「合并」的语义是：所有横坐标为 x 的石头和所有纵坐标为 y 的石头都属于同一个连通分量。
    
    并查集里如何区分横纵坐标
    然而会遇到这样一个问题：石头的位置是「有序数对（二维）」，并查集的底层是「一维数组」，我们在并查集里应该如何区分横纵坐标呢？
    
    例如：如果一块石头的坐标为 [3, 3] ，那么所有横坐标为 3 的石头和所有纵坐标为 3 的石头都在一个连通分量中，但是我们需要在并查集里区分「横坐标」和「纵坐标」，它们在并查集里不能相等，根据题目的提示 0 <= x_i, y_i <= 10^40<=x
    i,yi<=10^4
    ，可以把其中一个坐标 映射 到另一个与 [0, 10000] 不重合的区间，可以的做法是把横坐标全部减去 1000110001 或者全部加上 1000110001（视频讲解有误，以此处为准），或者按位取反（[0, 10000] 里的 3232 位整数，最高位变成 11以后，一定不在 [0, 10000] 里）。
    
    在并查集里我们需要维护连通分量的个数，新创建顶点的时候连通分量加 11；合并不在同一个连通分量中的两个并查集的时候，连通分量减 11。

    题解代码：   

    func removeStones(stones [][]int) int {
        l := len(stones)
        cnt := 0
        m := make(map[int]int)
        for i:=0;i<l;i++{
         union(stones[i][0]+10000,stones[i][1],m,&cnt)
        }
        return l-cnt
    }
    
    func find(x int,m map[int]int,cnt *int)int{
        v,exist := m[x]
        if !exist {
            m[x] = x
            (*cnt)++
        }
        
        if x != v {
            //找到x上方的顶点，即m[x] = x的点
            m[x] = find(m[x],m,cnt)
        }
        return m[x]
    }
    
    func union(x,y int,m map[int]int,cnt *int){
        rootX := find(x,m,cnt)
        rootY := find(y,m,cnt)
        if rootX == rootY{
             return
        }
        //联合两个连同分量
        m[rootX] = rootY
        (*cnt)--
    }

### 收获
    
    这道题主要重新学习了并查集,从一维上升到了二维的层面,由此可推,上升到三维也可以的.在并查集中主要涉及查询和联合两个操作,查询就是查询当前结点属于哪个集合,联合就是将不同集合合并为同一个集合,合并优化这里暂且不讨论.

    最后再说一个"最原则",在并查集中,每一个集合属于哪个集合决定于如何选代表,比如说对于整型可以选最小,或者最大等,也可以选最早到达等,反正就是以"最"为原则.
    
