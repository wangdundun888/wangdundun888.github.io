### 49 丑数

    我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

### 17.09 第k个数

    有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。


今天是2020/12/16,点开了*第k个数*一番思考后发现和之前的丑数思路一致,但有些遗忘了,回头重新看了丑数,为了避免再次遗忘,我选择把自己的思考和所得写下来.

刚做丑数时,我选择了暴力解法:从1开始遍历,判断这个数是否为丑数,如果是,则计数加1,计数达到题目要求,便返回答案.
使用暴力解法,全部所得结果没有为后面提供支持,前后没有关联,所有超时是必然的.

然后我观看了题解,经过思考,a掉了丑数.但24天后的我依然没有解出同类型的第k个数,所以我选择写出自己的理解:

    1.一个丑数乘以2或3或5之后必定还是一个丑数
    2.一个丑数必定由前面的某个丑数乘以2或3或5之后所得(1除外)
    3.假设ans[1..n]为丑数数组,第i个便是我们所求的解
    对于ans分别乘以2,3,5之后得到数组a2,a3,a5,且ans内的所有元素
    都能在a2 a3 a5中找到(1除外),甚至有的重复,且a2 a3 a5都是一个升序数组.
    利用第2条性质,把a2 a3 a5三个排好序的数组去重合并为ans即可
    func nthUglyNumber(n int) int {
        ans := make([]int,n)
        var a,b,c int
        ans[0] = 1
        for i:=1;i<n;i++{
            //利用前面的丑数和下标,并不用构造a2 a3 a5数组
            a2,a3,a5 := ans[a]*2,ans[b]*3,ans[c]*5
            //选择最小那个
            ans[i] = min(a2,a3,a5)
            //将选择过的下标往前移一位,并且看看其他有没有等于当前ans[i]的,即重复的,也往前移一位
            if ans[i] == a2 {
                a++
            }
            if ans[i] == a3 {
                b++
            }
            if ans[i] == a5 {
                c++
            }
        }
        return ans[n-1]
    }